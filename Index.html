<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Santiago Cortes GitPage</title>
    <link rel="stylesheet" href="styles.css">

</head>
<body>
    <div class="encabezado">
        <nav class="navegacion" id="navegacion">
            <button onclick="cambiarContenido('introducción', this)">Introducción </button>
            <button onclick="cambiarContenido('contenido1', this)">UNIDAD 1 </button>
            <button onclick="cambiarContenido('contenido2', this)">UNIDAD 2 </button>
            <button onclick="cambiarContenido('contenido3', this)">UNIDAD 3 </button>
        </nav>
    </div>
    
    <main id="mainContent">


        <div class="contenido" id="introducción"  style="display:block;">
            <h1>Introducción</h1>
            <p>
                ¡Bienvenidos a mi pagina web! Mi nombre es <Strong>Santiago Cortes Cortes</Strong> 
            </p>
            <p>
                Esta página, se estructura en tres unidades, cada una representando un corte en mis clases de Lenguajes de Programacion. 
            </p>

            <h2>Resumen:</h2>
            <p>
            <h3>Unidad 1: Introducción A Python Y Fundamentos</h3>
            Comenzaremos con las bases sólidas de la programación en Python, abordando conceptos fundamentales que sientan las bases para este lenguaje. 
            Como son las funciones puras, veremos que son las funciones de bajo orden y de alto orden, y desglosaremos las funciones map, filter y reduce.
            
            <h3>Unidad 2: Programación Orientada A Objetos En Python</h3>
            En esta unidad, veremos la programación orientada a objetos en Python. Examinaremos patrones de diseño fundamentales, como Observer, Strategy, Singleton y Adapter, 
            que constituyen herramientas poderosas para estructurar y organizar el código de manera eficiente.
            
            <h3>Unidad 3: Java Concurrency</h3>
            Por ultimo tenemos la concurrencia en Java. Exploraremos paradigmas de programación, desde el enfoque estructurado hasta el funcional, 
            y Exploraremos la programación concurrente, destacando la importancia de los hilos en Java.
            </p>
        </div>
        <!-- Contenido del corte 1 -->
        <div class="contenido" id="contenido1"  style="display:none;">

            <h1>Introducción A Python Y Fundamentos</h1>
            <h2>Funciones Puras:</h2>
            <p> 
                Las funciones puras son aquellas que, al recibir los mismos argumentos, 
                siempre retornan el mismo resultado. 
                Estas funciones no modifican el esdado de las variables o elementos fuera de su ámbito 
                local, esto lo podemos lograr al crear copias de las variables que le pasemos. 
                <br> Su principal característica es la previsibilidad y la ausencia de cambios colaterales
            </p>
            <div class="caja-codigo"><code>
<span class="nota">#Una funcion pura en python 

#Untrada: un lista de enteros
#salida: una Copia de la lista de entrada, con sus valores ^2</span>

def unaFuncionPura(listaDeEntrada):
    <span class="nota">#Una lista vacia en Python</span>
    listaSalida = []
    <span class="nota">#Iterador en una lista</span>
    for x in listaDeEntrada:
        <span class="nota">#agregando un elemento a una lista</span>
        listaSalida.append(x**2)

    return listaSalida
        </code></div>

            <h2>Funciones de bajo orden y de alto orden:</h2>
            <p>
                En programación funcional, <strong>las funciones de bajo orden</strong> las funciones de bajo orden son aquellas que reciben o devuelven valores simples. <br>
                <strong>Las funciones de alto orden</strong> son aquellas que pueden recibir funciones como argumentos y/o devolver funciones como resultados. 
            </p>
            <h2>Funciones map, filter y reduce:</h2>
            <p>
                Estas son funciones integradas en Python que operan sobre secuencias (como listas) y aplican operaciones a cada elemento.
            </p>

            <div class="caja-codigo"><code>
<span class="nota">#Funcion para filtrar nuestra lista.
#Esta la pasareos a nuestra funcion filter, para que filtre: (los elementos que tengan menos de 80 especies de aves de un dataset, Humedales)</span>

def filtroAves(humedal):
    return humedal["especies de aves"] > 80

dataSetFiltrado = list(filter(filtroAves, miDataSet))
print(dataSetFiltrado)

<span class="nota">#Tambien podemos hacer uso de funciones anonimas (lanmda) como funcion para nuestro filter
                                #funcion  parametro     retorno</span>
dataSetFiltrado2 = list(filter( lambda    x:           x["hectarias"] > 4.0, miDataSet ))
        </code></div>

        </div>



        <!-- Contenido del corte 2 -->
        <div class="contenido" id="contenido2" style="display:none;">

            <h1>Programacion Orientada A Objetos En Python </h1>
            <p>
                En esta unidad, exploramos la Programación Orientada a Objetos en Python, un enfoque crucial para el desarrollo de software eficiente. 
                Abordamos diversos temas, incluyendo clases, relaciones, herencia y tipos (modularidad, reusabilidad, adaptabilidad y testeabilidad). 
                Además, analizamos conceptos fundamentales como el Modelo Vista Controlador y 
                exploramos patrones de diseño clave, como Observer, Strategy, Singleton y Adapter, que desempeñan un papel crucial en la construcción de sistemas robustos y mantenibles.
            </p>
            <h2>Patrones De Diseño:</h2>
            <p>
                <strong>Los patrones de diseño</strong> son soluciones generalizadas para problemas comunes en el diseño de software. <br>
                Estos se aplican para mejorar la estructura, flexibilidad y mantenibilidad del código. 
            </p>

            <!-- Observer -->
            <h3>• Observer</h3>
            <p>
                El patrón <strong>Observer</strong> se utiliza para definir una dependencia uno a muchos entre objetos, 
                de manera que cuando un objeto cambia su estado, todos sus dependientes son notificados y actualizados automáticamente. <br>
                Este patrón se implementa utilizando clases observadoras y sujetos observados.
            </p>

            <div class="caja-codigo">
                <code>
<span class="nota">#Clase publisher que se encarga de actualizar o notificar a los subscritores</span>
class Publisher: 
    
    <span class="nota">#inicializar lista de observadores</span>
    def __init__(this):
        this._observers = []


    <span class="nota">#añade nuevos subscriptores</span>
    def addSubscriber(this, newSubscriber):
        this._observers.append(newSubscriber)
    <span class="nota">#Remueve subscrictores</span>
    def removeSubscriber(this, subscriber):
        this._observers.remove(subscriber)

    def notifySubscribers(this, message):
        <span class="nota">#enviar message a todos los subscritores en la lista:</span>
        for subscriber in this._observers:
            subscriber.Update(message)




class Subscriber:

    def Update(this, message):
        pass


class SubscriberType1(Subscriber):

    def Update(this, message):
        #return super().Update(message)
        print(f"Subscriber 1 recibi mensage {message}")


class SubscriberType2(Subscriber):

    def Update(this, message):
        #return super().Update(message)
        print(f"Subscriber 2 recibi mensage {message}")



<span class="nota">#Metodo principal:</span>
if __name__ == "__main__":

    <span class="nota">#Crear publisher</span>
    publisher1 = Publisher()
    
    <span class="nota">#Crear subscriptores u "observers"</span>
    obsserver1 = SubscriberType1()
    obsserver2 = SubscriberType2()
    
    <span class="nota">#agregar subscriptores</span>
    publisher1.addSubscriber(obsserver1)
    publisher1.addSubscriber(obsserver2)
    
    <span class="nota">#notificar subscriptores:</span>
    publisher1.notifySubscribers("checking my subscribers....")
    
                </code>
                </div>

            <!-- Strategy -->
            <h3>• Strategy</h3>
            <p>
                El patrón <strong> Strategy </strong>define una familia de algoritmos, encapsula cada uno de ellos y los hace intercambiables. 
                Esto permite que el cliente pueda elegir el algoritmo que desee utilizar en tiempo de ejecución. <br>
                Esto se logra a través de la definición de clases estrategia y un contexto que utiliza la estrategia seleccionada.
            </p>

            <div class="caja-codigo">
                <code>
<span class="nota">#strategy (Patron de comportamiento)
#Clase que define una estrategia en general</span>
class Strategy:
    
    def __init__(self, login, password):
        self.login = login
        self.password = password

    def execute():
        pass


<span class="nota">#Estrategias concretas:</span>
class AtentificacionGoogle(Strategy):

    def __init__(self, login, password, token1, token2):
        super().__init__(login, password)
        self.token1 = token1
        self.token2 = token2


    def execute(self):
        print ("Autentificado con Google")
        sesion = Sesion.createInstance()
        print(sesion)

class AtentificacionGitHub(Strategy):

    def execute(self):
        print ("Autentificado con GitHub")
        sesion = Sesion.createInstance()
        print(sesion)
        
class AtentificacionFacebook(Strategy):

    def execute(self):
        print ("Autentificado con Facebook")
        sesion = Sesion.createInstance()
        print(sesion)



<span class="nota">#La clase context es la que le permite al cliente ejecutar la estategia correspondiente:</span>
class Context:
    
    def __init__(self, strategy:Strategy):
        self.strategy = strategy
        
    def execute_strategy(self):
        self.strategy.execute()
                </code>
                </div>


            <!-- Singelton -->
            <h3>• Singelton</h3>
            <p>
                El patrón <strong> Singleton </strong> garantiza que una clase tenga solo una instancia y proporciona un punto global de acceso a esa instancia. <br>
                Esto se implementa mediante la creación de una clase con un método que siempre devuelve la misma instancia, si ya existe, o la crea si no.
            </p>

            <div class="caja-codigo">
                <code>
<span class="nota">#Ejemplo de singleton "clásico"</span>

class ClassicSingleton:

    _instance_ = None

    def __init__(this):
        raise RuntimeError("invocar la función create_instance para crear objeto")
    
    <span class="nota">#métodos de instancia</span>
    def enqueueDocument(this, fileName, format):
        pass

    def dispatchDocument(this, fileName):
        pass

    def deleteDocument(this, fileName):
        pass
    
    <span class="nota">#un "classmethod es un método estático"</span>
    @classmethod
    def createInstance(this):
        if this._instance_ is None:
            #lo hace solo una vez, cuando no se ha instanciado ningún objeto
            this._instance_ = this.__new__(this) 
            #__new__ lo usa internamente __init__ para crear una nueva instancia de clase
        
        return this._instance_
                </code>
                </div>

            <!-- Aadpter -->
            <h3>• Adapter</h3>
            <p>
                El patrón <strong> Adapter </strong> permite que interfaces incompatibles trabajen juntas. Sirve como un puente entre dos interfaces diferentes, 
                permitiendo que objetos con interfaces incompatibles colaboren de manera efectiva. <br>
                Este se utiliza para que dos clases o sistemas puedan interactuar sin tener que modificar su código fuente.
            </p>

            <div class="caja-codigo">
            <code>
<span class="nota">#Adapter (Patron estructural)
#Clase *adaptada con interfaz no compatible con el *Cliente a traves de un *adaptador

#Objetos con interfacez incopatibles sea utiles

#Clase con interfaz compatible</span>
class Adaptee:
    
    def __init__(self):
        pass


    def request_trans(self):
        return "Peticion adaptada a la interfaz del cliente"
    


<span class="nota">#Clase cliente</span>
class Client:
    
    def __init__(self):
        pass
    
    def request(self):
        return "Peticion del cliente (no compatible con la clase adaptada)"


<span class="nota">#Clase adaptadora</span>
class Adapter(Client):
    
    def __init__(self, adaptee:Adaptee):
        self.adaptee = adaptee
        
        
    def request(self):
        return self.adaptee.request_trans()
            </code>
            </div>

        </div>


        <!-- Contenido del corte 3 -->
        <div class="contenido" id="contenido3" style="display:none;">

            <h1>Java Concurrency</h1>

            <p>
                La programación concurrente se realiza a través del manejo de hilos. Un hilo es una unidad de ejecución independiente que permite realizar múltiples tareas simultáneamente. La programación concurrente se vuelve crucial para mejorar la eficiencia y la capacidad de respuesta de las aplicaciones.
            </p>
        
            <h2>Paradigmas:</h2>
        
            <h3>• Estructurado</h3>
            <p>
                En Java, se puede estructurar el código en funciones o métodos. Sin embargo, se puede lograr una mejor estructura con la encapsulación y la modularidad, utilizando clases y objetos para estructurar el código de manera más efectiva.
            </p>
        
            <h3>• Orientado a Objetos:</h3>
            <p>
                Java es un lenguaje de programación orientado a objetos, lo que significa que todo en Java es un objeto. Los conceptos clave de la programación orientada a objetos, como encapsulamiento, herencia y polimorfismo, son fundamentales en Java.
            </p>
        
            <h3>• Funcional:</h3>
            <p>
                Aunque Java es principalmente un lenguaje orientado a objetos, a partir de la versión 8, introdujo características de programación funcional. La adición de expresiones lambda y Streams API permite un estilo de programación más funcional, facilitando operaciones en colecciones de datos de manera concisa.
            </p>
        
            <h3>• Concurrente:</h3>
            <p>
                La programación concurrente en Java es una característica esencial. La capacidad de trabajar con múltiples hilos permite que las aplicaciones realicen tareas simultáneas, mejorando el rendimiento y la capacidad de respuesta. Java proporciona herramientas y bibliotecas, como el paquete `java.util.concurrent`, para facilitar la implementación de la concurrencia de manera segura.
            </p>
        
            <h1>Hilos en Java</h1>
        
            <p>
                Los hilos permiten que varias tareas se ejecuten simultáneamente, mejorando la eficiencia y la capacidad de respuesta de una aplicación.
            </p>
        
            <p>A continuación se muestra y explica la ejecución de un programa haciendo uso de los hilos en Java.</p>
        
            <ul>
                <li><h2>Creación de una Clase Principal (MainClass):</h2>
                    <ul>
                        <li>Se define una clase principal que contiene el método main, el punto de entrada del programa.</li>
                        <li>Se crea una instancia de la clase Account, que representa una cuenta bancaria.</li>
                    </ul>
                </li>
        
                <li><h2>Creación de Hilos:</h2>
                    <ul>
                        <li>Se crean dos hilos (hiloRetiro y hiloDeposito) utilizando la clase Thread. Estos hilos realizan operaciones de retiro y depósito en la cuenta myAccount respectivamente.</li>
                        <li>Se crea un arreglo de hilos (hilosRetiro) para simular retiros concurrentes en un bucle.</li>
                    </ul>
                </li>
        
                <li><h2>Implementación de la Clase Account:</h2>
                    <ul>
                        <li>La clase Account representa la cuenta bancaria y contiene métodos sincronizados (withdraw y deposit) para garantizar la coherencia en operaciones concurrentes.</li>
                        <li>El método withdraw verifica que haya suficiente saldo antes de realizar un retiro y utiliza la palabra clave synchronized para evitar problemas de concurrencia.</li>
                    </ul>
                </li>
        
                <li><h2>Iniciando los Hilos:</h2>
                    <ul>
                        <li>Los hilos se inician llamando al método start() en cada instancia de Thread. Esto activa la ejecución del método run asociado.</li>
                    </ul>
                </li>
        
                <li><h2>Gestión de Concurrencia:</h2>
                    <ul>
                        <li>Se utiliza el método join para esperar a que los hilos (hiloDeposito, hiloRetiro y los hilos en hilosRetiro) finalicen su ejecución antes de continuar con el hilo principal (main).</li>
                    </ul>
                </li>
        
                <li><h2>Resultado Final:</h2>
                    <ul>
                        <li>Se imprime el balance final de la cuenta después de que todos los hilos han completado sus operaciones.</li>
                    </ul>
                </li>
            </ul>

            <div class="caja-codigo">
            <code>
<span class="nota">//Main.js </span>
public class MainClass {
	
	<span class="nota">//Metodo que se ejecuta para cada instancia del hilo</span>
	public void run()
	{
		System.out.println("Ejecutando hilo"+ Thread.currentThread().getId());
	}



	public static void main(String[] args) throws InterruptedException
	{
		Account myAccount = new Account(250000);
		
		<span class="nota">//Crear 2 hilos para las dos operaciones sobre la cuenta </span>
		Thread hiloRetiro = new Thread(	()-> myAccount.withdraw(0)	);
		Thread hiloDeposito = new Thread(	()-> myAccount.deposit(0)	);
		
		
		<span class="nota">//Crear un arreglo de hilos que invocan el mismo metodo:</span>
		Thread [] hilosRetiro = new Thread[8];
		for(int i = 0; i<hilosRetiro.length; i++)
		{
			hilosRetiro[i] = new Thread( ()-> myAccount.withdraw(100000) );
			hilosRetiro[i].start();
		}


		<span class="nota">//Iniciar los hilos</span>
		hiloRetiro.start();
		hiloDeposito.start();



		<span class="nota">//Unir los hilos a este hilo principal (main) e imprime el id de cada hilo</span>
		try {

			hiloDeposito.join();
			hiloRetiro.join();
			for(Thread t: hilosRetiro)
			{
				t.join();
				System.out.println(t.getId());
			}
				

		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		<span class="nota">//De aqui en adelante, se espera que ambos hilos terminen
		//gracias a que llame la funcion join en cada uno de ellos.</span>

		System.out.println("Balance final: "+myAccount.getBalance());

        <span class="nota">//operaciones secuenciales:</span>
		myAccount.deposit(500000);
		myAccount.withdraw(40000);
	}

}


<span class="nota">//Modulo Account</span>
public class Account {
	
	private float balance;
	
	
	public Account(float initialBalance)
	{
		this.balance = initialBalance;
	}
	
	/**
	 * retiro
	 * @param amount
	 */
	public synchronized void withdraw(float amount)
	{
		//validar balance >= valor a retirar
		if(balance >= amount)
			balance -= amount;
	}
	
	/**
	 * depósito
	 * @param amount
	 */
	public synchronized void deposit(float amount)
	{
		balance += amount;
	}

	public float getBalance()
	{
		return balance;
	}
}

            </code>
            </div>

        </div>
    </main>
    <script src="script.js"></script>

</body>
</html>
